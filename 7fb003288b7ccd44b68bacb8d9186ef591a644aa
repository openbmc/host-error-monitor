{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2af4e841_f25a9153",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000276
      },
      "writtenOn": "2023-04-27T16:36:54Z",
      "side": 1,
      "message": "Overall it\u0027s looking good.  The code is simpler and doesn\u0027t seem to be impacted by D-Bus performance in my testing.\n\nIn my testing, I ran into a strange D-Bus issue and a startup order issue.  But once we work through those, everything looks good on my system.",
      "revId": "7fb003288b7ccd44b68bacb8d9186ef591a644aa",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93cc9165_13fd0ffe",
        "filename": "src/host_error_monitor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1000276
      },
      "writtenOn": "2023-04-27T16:36:54Z",
      "side": 1,
      "message": "I\u0027m running into an issue here if host-error-monitor starts before power-control.  I think what happens is it returns here without calling the callback below.\n\nThen in base_gpio_poll_monitor, since the callback isn\u0027t called, it doesn\u0027t execute either the `waitForEvent()` or `poll()` calls, which I think leaves the signal monitor in a dead state.\n\nI\u0027m not sure the best way to handle it.  We could always call the callback with either a default or error value and handle it in the callback.  Or we could adjust in base_gpio_poll_monitor so that even if the callback doesn\u0027t run, the signal monitor keeps running.  What do you think?",
      "revId": "7fb003288b7ccd44b68bacb8d9186ef591a644aa",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39a211bc_f144851d",
        "filename": "src/host_error_monitor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-04-27T23:01:26Z",
      "side": 1,
      "message": "Ah, yeah...I guess I\u0027d be inclined to pass along the \"unknown\" host-state value to the callback and let it decide what to do in cases where the state check fails.  The existing code seems to implicitly assume the host is off at startup (due to the `hostOff \u003d true` initialization), and then after that I guess would just maintain its notion of the current state as whatever update signal it saw last if power-control crashes or something.  With this patch in its current form we no longer have that state-tracking to fall back on, so we could either just have each callback decide what assumption about the host\u0027s power state is most appropriate for it, or revive the global variable purely to serve as a fallback if the dbus query fails...thoughts?",
      "parentUuid": "93cc9165_13fd0ffe",
      "revId": "7fb003288b7ccd44b68bacb8d9186ef591a644aa",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1168fa8_c50e82b6",
        "filename": "src/host_error_monitor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1000276
      },
      "writtenOn": "2023-04-28T17:41:22Z",
      "side": 1,
      "message": "I\u0027m leaning towards no global variable and let each callback decide how to handle the response from the state check.  It seems to be the most flexible and as you said, will allow the most appropriate response from each callback.",
      "parentUuid": "39a211bc_f144851d",
      "revId": "7fb003288b7ccd44b68bacb8d9186ef591a644aa",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6a69b48d_504ca051",
        "filename": "src/host_error_monitor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-04-28T23:02:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e1168fa8_c50e82b6",
      "revId": "7fb003288b7ccd44b68bacb8d9186ef591a644aa",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "da9a0a01_ffb424a0",
        "filename": "src/host_error_monitor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1000276
      },
      "writtenOn": "2023-05-02T20:33:51Z",
      "side": 1,
      "message": "Hmm... I\u0027m still seeing it hang if I start power-control after host-error-monitor, so that didn\u0027t fix it. ðŸ˜•\n\nWithout power-control, it gets a `No route to host` error. Everything seems to be fine until that error, then host-error-monitor just hangs waiting for the next call to checkHostState().\n\nHowever, while it\u0027s hung there, I can read the host state using `busctl`. I wonder if it\u0027s something in sdbusplus that is trying to protect host-error-monitor by blocking D-Bus to the same host after getting the \"No route\" error.\n\nDo you see this issue if you start power-control after host-error-monitor? Or stop and start power-control while host-error-monitor is running?",
      "parentUuid": "6a69b48d_504ca051",
      "revId": "7fb003288b7ccd44b68bacb8d9186ef591a644aa",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e5e16ba_207d25dc",
        "filename": "src/host_error_monitor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1000276
      },
      "writtenOn": "2023-04-27T16:36:54Z",
      "side": 1,
      "message": "I am running into an issue here on my system where when a signal monitor that inherits base_gpio_poll_monitor is started, it tries to check the host state, but seems to hang waiting for D-Bus.\n\nI made the following change in a test build that seems to resolve the issue and mimics the current behavior where the signal monitors are initialized after io.run() starts:\n\n```\n-    // Initialize the signal monitors\n-    host_error_monitor::init();\n+    boost::asio::post(host_error_monitor::io, []() {\n+        // Initialize the signal monitors\n+        host_error_monitor::init();\n+    });\n```",
      "revId": "7fb003288b7ccd44b68bacb8d9186ef591a644aa",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4de6c136_2ff47ba4",
        "filename": "src/host_error_monitor.cpp",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-04-27T23:01:26Z",
      "side": 1,
      "message": "Ah, okay -- I\u0027ll incorporate that tweak into the next version of the patch, thanks.",
      "parentUuid": "6e5e16ba_207d25dc",
      "revId": "7fb003288b7ccd44b68bacb8d9186ef591a644aa",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}